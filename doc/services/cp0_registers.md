# CP0寄存器服务

CP0寄存器服务用于注册CP0寄存器字段，字段本身由各个组件自行管理，CP0读写指令会进行相应的查找和设置。
相关代码位于[CP0Regs](/ZenCove/src/zencove/core/CP0Regs.scala)。

## 简介

在Plugin的setup方法中，可以向`CP0Regs`服务（对象）注册一系列CP0寄存器域，在每个
`addr = (num<<3)|sel`下，均为`offset->信号对象`的二元组，其中offset为字段的最低地址，字段长度由信号对象长度定义。还可以注册读写回调，如果一个域并不是直接读或者直接写的话。

## 注意事项

CP0寄存器字段有以下几种修改方式：

1. 自身状态转移（由各个组件自行管理，例如异常发生时）；
1. 写指令直接写字段；
1. 读写指令的回调中写字段（例如写Wired寄存器会重置Random寄存器）。

以上修改方式的覆盖关系是*未定义*的。暂时没有看出需要定义覆盖关系情况。

目前在乱序场景下CP0写在提交时进行，CP0读在乱序执行时进行，因此读不可产生副作用，否则需要按照uncached load处理。

## 推荐使用方法

一般情况下，CP0寄存器的地址应该在`MIPS32.CP0`下定义。在setup函数中，向`pipeline.cp0`注册r/w域(rw=r+w)。一个地址可以多次调用函数注册多个直接域/读写回调。由于读写回调可能不是很常用，注释不太详细，有什么需求可以之后再提出。每一个域由其最低位地址标志，其长度由其信号值的长度推断，不同的域之间**没有检查覆盖问题**（这个可以TODO）。

一个地址的不同域可以在不同模块的setup函数中注册。这是一个非常好用的特性。以RISC-V为例，mstatus寄存器既有exception相关的状态位，也有内存相关的状态位，这样可以在ExceptionHandler中处理exception位，在MMU中处理内存位。

不是非常建议在setup中编写过多的硬件逻辑描述，虽然这大概也不会导致什么问题。因此可以在Plugin中的成员变量定义域信号，在setup中将信号注册给CP0，在build中编写具体的信号值内部状态转移。因读写指令造成的进一步状态转移可能应该注册成回调，在build中不处理读写指令的逻辑，但要记得读写可能造成的副作用。

具体的例子可以看[Counter](/ZenCove/src/zencove/core/Counter.scala)。
