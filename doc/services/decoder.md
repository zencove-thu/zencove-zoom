# 解码服务

解码服务提供了注册指令mask及解码动作而自动生成解码硬件逻辑的服务。
相关实现代码位于[DecoderArray](/ZenCove/src/zencove/core/DecoderArray.scala)。

## 简介

在Plugin的setup方法中，可以

1. 向decoder服务（对象）为每个指令编码注册一系列解码动作，均为`信号key->信号值`的二元组。
2. 为一个信号key注册其默认值。

解码信号必须有默认值，但可以是don't care，这规定了在解码动作中不包含此信号key时的信号值。
一个指令只需要设置其关心的解码信号，其余信号会被自动设置为默认值。

## 具体使用方法

一般情况下，指令编码应当在`zencove.MIPS32`中规定。注意这里定义的是硬件匹配的mask。强烈建议使用makeInst方法生成mask，而不是手写32位的mask。makeInst方法的定义参考其注释。

对每一类指令，推荐在其主要操作模块中注册解码动作。在哪个模块的setup方法注册解码动作并没有影响，但是这样会更加清晰，更好的模块化。若某一类指令需要添加独有的解码信号，推荐在对应的模块中为信号注册默认值，然后在解码动作注册其特殊值。因此假设共有m条指令，解码信号集合有n个信号，并不需要设置m\*n个解码动作，只需要对其非默认的信号进行设置即可，这通常而言是相当稀疏的。

推荐采用合并同类项的方式规定解码动作，避免一类指令相同动作重复编写。使用Seq的`++`方法串联列表，或`:+`进行列表和项目的串联。

并非所有信号都要写在`PipelineSignals`中，如果你认为一个信号仅有这个模块（以及其指令解码）需要关心，那么将`Stageable`就定义在这个文件里也非常好，但要注意是否是单例，否则引用的对象就可能不同。

在乱序场景下，由于需要设计micro OP，因此将解码均塞在了一起，但这不是必须的。

Outdated: 当前已经支持输入Any类型，匹配Data或SpinalEnumElement，后者转换为SpinalEnumCraft。
(Note: `MyEnum.VALUE1`可能导致类型推断为`SpinalEnumElement`而失败，如果遇到这样的情况，要么显式指定类型为`Data`，要么写为`MyEnum.VALUE1()`，这两种等价的方法都会使得类型显式变为`SpinalEnumCraft`。)

### 与仿真配合

**DEPRECATED:** 不推荐在scala里手写指令进行仿真。在Verilator能跑通仿真的情况下，更推荐通过LoongSim等方式直接读取汇编出的binary文件进行CPU仿真。

`zencove.sim.MIPSInst`为仿真提供了指令生成服务。这里在指令硬编码的基础上填充了可变域，生成具体的指令值。一般将指令方法定义成汇编的格式，实现的指令mask直接从MIPS32调取，如有需要也可以增加Type。
